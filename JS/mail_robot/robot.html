<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Mail Robot</title>
    <style>
        /* #display {
            border: 2px solid lightgray;
        } */

        /* #display {
            position: absolute;
            top: 100px;
            left: 100px;
        } */
    </style>
</head>
<body>
<div id="main">
    <!-- <canvas id="display" width="500" height="300"></canvas> -->
</div>

</body>
<script>

    const mapScale = 5;
    const displayWidth = 100;  // units
    const displayHeight = 60;
    const placeSize = 6;
    const robotSize = placeSize * 2 / 3;
    const parcelSize = placeSize / 3;

    const places = [
        "Alice's House,70,20", "Bob's House,80,35", "Cabin,90,5", "Post Office,40,5",
        "Town Hall,50,35", "Ernie's House,12,47", "Grete's House,5,30",
        "Daria's House,40,47", "Farm, 10,10", "Shop,25,35", "Marketplace,35,20"
    ];
    const roads = [
        "Alice's House-Bob's House",   "Alice's House-Cabin",
        "Alice's House-Post Office",   "Bob's House-Town Hall",
        "Daria's House-Ernie's House", "Daria's House-Town Hall",
        "Ernie's House-Grete's House", "Grete's House-Farm",
        "Grete's House-Shop",          "Marketplace-Farm",
        "Marketplace-Post Office",     "Marketplace-Shop",
        "Marketplace-Town Hall",       "Shop-Town Hall"
    ];
    const roadGraph = (() => {
        let nodes = {};
        places.forEach(place => {
            place = place.split(",");
            nodes[place[0]] = {x: place[1], y: place[2]};
        });

        function addEdge(from, to) {
            if (nodes[from].neighbors == null) {
                nodes[from].neighbors = [to];
            } else {
                nodes[from].neighbors.push(to);
            }
        };
        for (let [from, to] of roads.map(r => r.split("-"))) {
            addEdge(from, to);
            addEdge(to, from);
        }
        // {"Alice's House": {x: 70, y: 20, neighbors: ["Bob's House", ..., ]}, ... }
        return nodes;
    })();

    class VillageState {
        constructor(place, parcels) {
            this.place = place;
            this.parcels = parcels;
        }

        move(destination) {
            if (!roadGraph[this.place.neighbors].includes(destination)) {
                return this;
            } else {
                let parcels = this.parcels.map(p => {
                    if (p.place != this.place) return p;
                    return {place: destination, address: p.address};
                }).filter(p => p.place != p.address);

                return new VillageState(destination, parcels);
            }
        }
    };

    function randomPick(array) {
        let choice = Math.floor(Math.random() * array.length);
        return array[choice];
    };
    VillageState.random = function(parcelCount = 5) {
        let parcels = [];
        for (let i = 0; i < parcelCount; i++) {
        let address = randomPick(Object.keys(roadGraph));
        let place;
        do {
            place = randomPick(Object.keys(roadGraph));
        } while (place == address);
        parcels.push({place, address});
        }
        return new VillageState("Post Office", parcels);
    };

    document.addEventListener("DOMContentLoaded", () => {
        let display = document.createElement("canvas");
        display.setAttribute("width", displayWidth * mapScale);
        display.setAttribute("height", displayHeight * mapScale);
        display.setAttribute("id", "display");
        display.style.border = "2px solid lightgray";
        document.getElementById("main").appendChild(display);
    });
    
    function scaled(value) {
        return value * mapScale;
    };

    function realCoords({x, y}) {
        return {x: scaled(x), y: scaled(y)};
    };

    function squareCenter(left, top, side) {
        return {x: left + side/2, y: top + side/2};
    };

    function textStartInSquare(x, y, squareSide) {
        let textX = x + squareSide/4, textY = y + squareSide*3/4;
        return {x: textX, y: textY};
    };

    function placeBottomLeft(name) {
        let topLeft = realCoords(roadGraph[name]);
        return {x: topLeft.x, y: topLeft.y + scaled(placeSize)};
    };

    function robotTopLeft(state) {
        let placeTopLeft = realCoords(roadGraph[state.place]);
        let robotLeft = placeTopLeft.x + scaled(placeSize/2);
        let robotTop = placeTopLeft.y + scaled(placeSize);
        return {x: robotLeft, y: robotTop};
    };

    function robotBottomRight(state) {
        let topLeft = robotTopLeft(state); 
        return {x: topLeft.x + scaled(robotSize), y: topLeft.y + scaled(robotSize)};
    };

    function drawVillageMap() {
        let ctx = document.getElementById("display").getContext("2d");
        for (let name of Object.keys(roadGraph)) {
            let place = roadGraph[name];
            let {x, y} = realCoords(place);
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.strokeRect(x, y, scaled(placeSize), scaled(placeSize));
            ctx.closePath();
            
            ctx.font = `${scaled(placeSize/2)}pt Arial`;
            let textStart = textStartInSquare(x, y, scaled(placeSize));
            ctx.fillText(name[0], textStart.x, textStart.y);
            let placeCenter = squareCenter(x, y, scaled(placeSize));
            place.neighbors.forEach(n => {
                let nCoords = realCoords(roadGraph[n])
                let nCenter = squareCenter(nCoords.x, nCoords.y, scaled(placeSize));
                ctx.beginPath();                
                ctx.moveTo(placeCenter.x, placeCenter.y);
                ctx.lineTo(nCenter.x, nCenter.y);
                ctx.stroke();
                ctx.closePath();
            });
        }
    };

    function drawRobot(state) {
        let {x, y} = robotTopLeft(state);
        let textStart = textStartInSquare(x, y, scaled(robotSize));

        let ctx = document.getElementById("display").getContext("2d");
        ctx.beginPath();
        ctx.strokeRect(x, y, scaled(robotSize), scaled(robotSize));
        ctx.font = `${scaled(robotSize/2)}pt Arial`;
        ctx.fillText("R", textStart.x, textStart.y);
        ctx.closePath();
    };

    function drawParcels(state) {
        let byPlace = {};
        state.parcels.forEach(p => {
            let place = p.place == state.place ? "Robot" : p.place;
            if (byPlace[place] == null) {
                byPlace[place] = [p.address[0]];
            } else {
                byPlace[place].push(p.address[0]);
            }
        });
        let ctx = document.getElementById("display").getContext("2d");
        let pSize = scaled(parcelSize);
        for (let parcelPlace of Object.keys(byPlace)) {
            let parcelsPileStart, x, y;
            if (parcelPlace == "Robot") {
                parcelsPileStart = robotBottomRight(state);
                x = parcelsPileStart.x + pSize / 3;
                y = parcelsPileStart.y - pSize;
            } else {
                parcelsPileStart = placeBottomLeft(parcelPlace);
                x = parcelsPileStart.x - pSize * 4/3;
                y = parcelsPileStart.y - pSize;
            }
            
            byPlace[parcelPlace].forEach(item => {
                ctx.beginPath();
                ctx.strokeRect(x, y, pSize, pSize);
                let textStart = textStartInSquare(x, y, pSize);
                ctx.font = `${pSize/2}pt Arial`;
                ctx.fillText(item, textStart.x, textStart.y);
                y -= pSize;
                ctx.closePath();
            });
        }

        // console.log(byPlace);

    }

    document.addEventListener("DOMContentLoaded", () => {
        drawVillageMap();
        let state = VillageState.random();
        drawRobot(state);
        // console.log(state);
        drawParcels(state);
    });



</script>

</html>