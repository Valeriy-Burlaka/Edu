<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Mail Robot</title>
</head>
<body>
<div id="main">
    <div>
        <canvas id="display"></canvas>
    </div>
    <div id="toolbar">
        <span>Select Robot:
            <select name="robots" id="robots"></select>
        </span><br>
        <span>Robot Speed:
            <select name="robot-speed" id="robot-speed">
                <option>1</option>
                <option>2</option>
                <option>3</option>
                <option>4</option>
                <option>5</option>
            </select>
        </span><br>
        <button id="start">Start Robot</button>
    </div>
    <div id="monitor">
        <span>Current Turn: <span id="turn">0</span></span><br>
        <span>Current Place: <span id="place">--</span></span><br>
    </div>
</div>

</body>
<script>

    const mapScale = 5;
    const displayWidth = 100;  // units
    const displayHeight = 60;
    const placeSize = 7;
    const robotSize = placeSize * 2 / 3;
    const parcelSize = placeSize / 3;

    const places = [
        "Alice's House,70,20", "Bob's House,80,35", "Cabin,90,5", "Post Office,40,5",
        "Town Hall,50,35", "Ernie's House,12,47", "Grete's House,5,30",
        "Daria's House,40,47", "Farm, 10,10", "Shop,25,35", "Marketplace,35,20"
    ];
    const roads = [
        "Alice's House-Bob's House",   "Alice's House-Cabin",
        "Alice's House-Post Office",   "Bob's House-Town Hall",
        "Daria's House-Ernie's House", "Daria's House-Town Hall",
        "Ernie's House-Grete's House", "Grete's House-Farm",
        "Grete's House-Shop",          "Marketplace-Farm",
        "Marketplace-Post Office",     "Marketplace-Shop",
        "Marketplace-Town Hall",       "Shop-Town Hall"
    ];
    const roadGraph = (() => {
        let nodes = {};
        places.forEach(place => {
            place = place.split(",");
            nodes[place[0]] = {x: place[1], y: place[2]};
        });

        function addEdge(from, to) {
            if (nodes[from].neighbors == null) {
                nodes[from].neighbors = [to];
            } else {
                nodes[from].neighbors.push(to);
            }
        };
        for (let [from, to] of roads.map(r => r.split("-"))) {
            addEdge(from, to);
            addEdge(to, from);
        }
        // {"Alice's House": {x: 70, y: 20, neighbors: ["Bob's House", ..., ]}, ... }
        return nodes;
    })();

    class VillageState {
        constructor(place, parcels) {
            this.place = place;
            this.parcels = parcels;
        }

        move(destination) {
            // console.dir(roadGraph[this.place]);
            if (!roadGraph[this.place].neighbors.includes(destination)) {
                return this;
            } else {
                let parcels = this.parcels.map(p => {
                    if (p.place != this.place) return p;
                    return {place: destination, address: p.address};
                }).filter(p => p.place != p.address);

                return new VillageState(destination, parcels);
            }
        }
    };

    function randomPick(array) {
        let choice = Math.floor(Math.random() * array.length);
        return array[choice];
    };

    VillageState.random = function(parcelCount = 5) {
        let parcels = [];
        for (let i = 0; i < parcelCount; i++) {
        let address = randomPick(Object.keys(roadGraph));
        let place;
        do {
            place = randomPick(Object.keys(roadGraph));
        } while (place == address);
        parcels.push({place, address});
        }
        return new VillageState("Post Office", parcels);
    };

    function elt(name, attributes) {
        let node = document.createElement(name);
        if (attributes) {
        for (let attr in attributes)
            if (attributes.hasOwnProperty(attr))
            node.setAttribute(attr, attributes[attr]);
        }
        for (let i = 2; i < arguments.length; i++) {
        let child = arguments[i];
        if (typeof child == "string")
            child = document.createTextNode(child);
        node.appendChild(child);
        }
        return node;
    };
    
    function getContext() {
        return document.getElementById("display").getContext("2d");
    };

    function clearDisplay(ctx) {
        ctx.clearRect(0, 0, scaled(displayWidth), scaled(displayHeight));
    };

    function scaled(value) {
        return value * mapScale;
    };

    function realCoords({x, y}) {
        return {x: scaled(x), y: scaled(y)};
    };

    function squareCenter(left, top, side) {
        return {x: left + side/2, y: top + side/2};
    };

    function textStartInSquare(x, y, squareSide) {
        let textX = x + squareSide/4, textY = y + squareSide*3/4;
        return {x: textX, y: textY};
    };

    function textSettings(size, family="Arial") {
        return `${size/2}pt ${family}`;
    }

    function placeBottomLeft(name) {
        let topLeft = realCoords(roadGraph[name]);
        return {x: topLeft.x, y: topLeft.y + scaled(placeSize)};
    };

    function robotTopLeft(state) {
        let placeTopLeft = realCoords(roadGraph[state.place]);
        let robotLeft = placeTopLeft.x + scaled(placeSize/2);
        let robotTop = placeTopLeft.y + scaled(placeSize);
        return {x: robotLeft, y: robotTop};
    };

    function robotBottomRight(state) {
        let topLeft = robotTopLeft(state); 
        return {x: topLeft.x + scaled(robotSize), y: topLeft.y + scaled(robotSize)};
    };

    function drawVillageMap() {
        let ctx = getContext();
        for (let name of Object.keys(roadGraph)) {
            let place = roadGraph[name];
            let {x, y} = realCoords(place);
            let pSize = scaled(placeSize);

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.strokeRect(x, y, pSize, pSize);
            ctx.closePath();
            
            ctx.font = textSettings(pSize);
            let textStart = textStartInSquare(x, y, pSize);
            ctx.fillText(name[0], textStart.x, textStart.y);

            let placeCenter = squareCenter(x, y, pSize);
            place.neighbors.forEach(n => {
                let nCoords = realCoords(roadGraph[n])
                let nCenter = squareCenter(nCoords.x, nCoords.y, pSize);
                ctx.beginPath();                
                ctx.moveTo(placeCenter.x, placeCenter.y);
                ctx.lineTo(nCenter.x, nCenter.y);
                ctx.stroke();
                ctx.closePath();
            });
        }
    };

    function drawRobot(state) {
        let {x, y} = robotTopLeft(state);
        let textStart = textStartInSquare(x, y, scaled(robotSize));

        let ctx = document.getElementById("display").getContext("2d");
        ctx.beginPath();
        ctx.strokeRect(x, y, scaled(robotSize), scaled(robotSize));
        ctx.font = textSettings(scaled(robotSize));
        ctx.fillText("R", textStart.x, textStart.y);
        ctx.closePath();
    };

    function drawParcels(state) {
        let byPlace = {};
        state.parcels.forEach(p => {
            let place = p.place == state.place ? "Robot" : p.place;
            if (byPlace[place] == null) {
                byPlace[place] = [p.address[0]];
            } else {
                byPlace[place].push(p.address[0]);
            }
        });
        let ctx = getContext();
        let pSize = scaled(parcelSize);
        for (let parcelPlace of Object.keys(byPlace)) {
            let parcelsPileStart, x, y;
            if (parcelPlace == "Robot") {
                parcelsPileStart = robotBottomRight(state);
                x = parcelsPileStart.x + pSize / 3;
                y = parcelsPileStart.y - pSize;
            } else {
                parcelsPileStart = placeBottomLeft(parcelPlace);
                x = parcelsPileStart.x - pSize * 4/3;
                y = parcelsPileStart.y - pSize;
            }
            
            byPlace[parcelPlace].forEach(item => {
                ctx.beginPath();
                ctx.strokeRect(x, y, pSize, pSize);
                let textStart = textStartInSquare(x, y, pSize);
                ctx.font = textSettings(pSize);
                ctx.fillText(item, textStart.x, textStart.y);
                y -= pSize;
                ctx.closePath();
            });
        }
    };

    function randomRobot(state) {
        return {direction: randomPick(roadGraph[state.place].neighbors)};
    };

    function routeRobot(state, memory) {
        const mailRoute = [
            "Alice's House", "Cabin", "Alice's House", "Bob's House",
            "Town Hall", "Daria's House", "Ernie's House",
            "Grete's House", "Shop", "Grete's House", "Farm",
            "Marketplace", "Post Office"
        ];
        if (memory.length == 0) {
        memory = mailRoute;
        }
        return {direction: memory[0], memory: memory.slice(1)};
    };

    function findRoute(graph, from, to) {
        let work = [{at: from, route: []}];
        for (let i = 0; i < work.length; i++) {
            let {at, route} = work[i];
            for (let place of graph[at].neighbors) {
                if (place == to) return route.concat(place);
                if (!work.some(w => w.at == place)) {
                    work.push({at: place, route: route.concat(place)});
                }
            }
        }
    };

    function goalOrientedRobot({place, parcels}, route) {
        if (route.length == 0) {
            let parcel = parcels[0];
            if (parcel.place != place) {
                route = findRoute(roadGraph, place, parcel.place);
            } else {
                route = findRoute(roadGraph, place, parcel.address);
            }
        }
        return {direction: route[0], memory: route.slice(1)};
    };

    function findNearestParcel(graph, place, parcels) {
        let nearestParcel = parcels[0];
        let shortestRouteLength = findRoute(graph, place, nearestParcel.place).length;
        parcels.slice(1).map(p => {
            let routeLength = findRoute(graph, place, p.place).length;
            //   console.log(`Place ${p.place} is ${routeLength} moves away from ${place}`);
            if (routeLength < shortestRouteLength) {
                shortestRouteLength = routeLength
                nearestParcel = p;
            }
        });
        // console.log(`${nearestParcel.place} is a nearest parcel`);
        return nearestParcel;
    };

    function nearestGoalOrientedRobot({place, parcels}, route) {
        if (route.length == 0) {
            let parcel = findNearestParcel(roadGraph, place, parcels);
            if (parcel.place != place) {
                route = findRoute(roadGraph, place, parcel.place);
            } else {
                route = findRoute(roadGraph, place, parcel.address);
            }
        }
        return {direction: route[0], memory: route.slice(1)};
    };

    function drawAll(ctx, state, turn) {
        clearDisplay(ctx);
        drawVillageMap();
        drawRobot(state);
        drawParcels(state);
        document.getElementById("turn").innerHTML = turn;
        document.getElementById("place").innerHTML = state.place;
    };

    function disableControls() {
        for (let id of ["robots", "start", "robot-speed"]) {
            document.getElementById(id).disabled = true;
        }
    };

    function enableControls() {
        for (let id of ["robots", "start", "robot-speed"]) {
            document.getElementById(id).disabled = false;
        }
    };

    function runRobotAnimation(state, robot, memory) {
        disableControls();
        let turn = 0;
        let ctx = getContext();
        drawAll(ctx, state, turn);

        function run() {
            turn++;
            let action = robot(state, memory);
            state = state.move(action.direction);
            drawAll(ctx, state, turn);
            if (state.parcels.length == 0) {
                clearInterval(interval);
                enableControls();
                return turn;
            }
            memory = action.memory;
        };
        let speed = parseInt(document.getElementById("robot-speed").value);
        let interval = setInterval(run, 500/speed);
    };

    document.addEventListener("DOMContentLoaded", () => {
        let main = document.getElementById("main");

        let display = document.getElementById("display");
        display.setAttribute("width", displayWidth * mapScale);
        display.setAttribute("height", displayHeight * mapScale);
        display.style.border = "2px solid lightgray";

        let robots = {
            "Route Robot": routeRobot,
            "Random Robot": randomRobot,
            "Goal-Oriented Robot": goalOrientedRobot,
            "Nearest Goal-Oriented Robot": nearestGoalOrientedRobot
        }
        let select = document.getElementById("robots");
        for (let robot in robots) {
            select.appendChild(elt("option", null, robot));
        }

        document.getElementById("start").addEventListener("click", () => {
            runRobotAnimation(VillageState.random(), robots[select.value], []);
        });
                        
    });

    document.addEventListener("DOMContentLoaded", () => {
        drawVillageMap();
    });

</script>

</html>