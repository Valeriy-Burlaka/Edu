<canvas width="1080" height="600" style="border: 2px solid lightgrey;"></canvas>
<script>
  "use strict";
  const canvasWidth = 1080;
  const ctx = document.querySelector("canvas").getContext("2d");

  function round(value, places) {
    let decimals = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 10000000, 100000000];
    if (places === undefined) {
      places = 0;
    }
    if (places > decimals.length) {
      throw new Error(`Unsupported number of decimal places.
        Can round up to ${decimals.length} places`);
    }
    value = Math.round(value * decimals[places]) / decimals[places];
    return value;
  };

  function distaneBetweenPoints(x0, y0, x1, y1) {
    let a = Math.pow(x1-x0, 2), b = Math.pow(y1-y0, 2);
    let dist = Math.sqrt(a + b);
    return round(dist, 2);
  }

  function lineSlope(x0, y0, x1, y1) {
    let slope = (y1 - y0) / (x1 - x0);
    return slope;
  };

  function drawStrokeLine(startX, startY, length, color) {
    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = color;
    for (let i=0; i<length; i+=20) {
      ctx.moveTo(i+10, startY);
      ctx.lineTo(i, startY);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  };

  function drawLongLineThroughTwoPoints(ctx, x0, y0, x1, y1) {
    // y = mx + b
    let slope = (y1 - y0) / (x1 - x0);
    let yIntercept = y1 - (slope * x1);
    // console.log(`x0: ${x0}, y0: ${y0}; x1: ${x1}, y1: ${y1}`);
    // console.log(`Slope (m): ${slope}, yIntercept: ${yIntercept}`);
    let leftY = slope + yIntercept;
    ctx.beginPath();
    ctx.moveTo(1, leftY);
    // let sineLength = parseInt(document.querySelector("canvas").getAttribute("width"));
    let rightY = slope*1200 + yIntercept;
    ctx.lineTo(1200, rightY);
    ctx.stroke();
  };

  function endPointsOfPerpendicular(x0, y0, x1, y1, length) {
    // console.log(`endPointsOfPerpendicular::had coordinates x0->${x0}, y0->${y0}, x1->${x1}, y1->${y1}`);
    let midpointX = (x1 + x0) / 2, midpointY = (y1 + y0) / 2;
    let lineSlope = (y1 - y0) / (x1 - x0);
    let perpendicularSlope = -(1 / lineSlope);
    let angle = Math.atan(perpendicularSlope);
    let x = midpointX + Math.cos(angle) * length;
    let y = midpointY + Math.sin(angle) * length;

    return {x0: midpointX, y0: midpointY, x1: x, y1: y};
  };

  function drawPerpendicular(ctx, x0, y0, x1, y1, length) {
    ctx.beginPath();
    let endpoints = endPointsOfPerpendicular(x0, y0, x1, y1, length);
    console.log(`drawPerpendicular::had coordinates x0->${x0}, y0->${y0}, x1->${x1}, y1->${y1};
      Calculated perpendicular endpoints: x0->${endpoints.x0}, y0->${endpoints.y0}, x1->${endpoints.x1}, y1->${endpoints.y1}`);
    ctx.moveTo(endpoints.x0, endpoints.y0);
    ctx.lineTo(endpoints.x1, endpoints.y1);
    ctx.stroke();
    ctx.closePath();
  };

  function* sineTrajectoryGen(start, length, amplitude) {
    let x0 = start
    let x1 = 0, y0 = 0, y1 = 0;
    for (let angle=start; angle<length; angle++) {
      x1 = angle;
      y1 = round(Math.sin(Math.PI*angle/180), 4) * amplitude;
      yield {x0: x0, y0: y0, x1: x1, y1: y1};
      x0 = x1;
      y0 = y1;
    }
  };

  function drawSine(start, length, amplitude) {
    ctx.beginPath();
    let sine = sineTrajectoryGen(start, length, amplitude);
    for (let coords of sine) {
      ctx.moveTo(coords.x1, coords.y1);
      ctx.lineTo(coords.x0, coords.y0);
      // if (coords.x0 % 300 === 0) {
      //   drawLongLineThroughTwoPoints(ctx, coords.x0, coords.y0, coords.x1, coords.y1);
      //   drawPerpendicular(ctx, coords.x0, coords.y0, coords.x1, coords.y1, 50);
      // }
    }
    ctx.stroke();
    ctx.closePath();
  };

  function drawCircleAdjacentToLine(ctx, x0, y0, x1, y1, circleRadius, onTop=true) {
    // console.log(`drawCircleAdjacentToLine::I'm called with x0->${x0}, y0->${y0}, x1->${x1}, y1->${y1}`);
    let slope = lineSlope(x0, y0, x1, y1);
    // drawLongLineThroughTwoPoints(ctx, x0, y0, x1, y1);
    // drawPerpendicular(ctx, x0, y0, x1, y1, 20);
    let perpPoints = endPointsOfPerpendicular(x0, y0, x1, y1, circleRadius);
    let middleX = perpPoints.x0, middleY = perpPoints.y0;
    let circleX = perpPoints.x1, circleY = perpPoints.y1;
    // [0,0] is left top corner; positive Y is at bottom;
    // negative slope looks like positive in this coordinate system
    // if (slope < 0) {
    //   drawLongLineThroughTwoPoints(ctx, x0, y0, x1, y1);
    //   console.log(`line slope: ${slope}; middle point: [${middleX}, ${middleY}]; circle center: [${circleX}, ${circleY}]`);
    // }
    if (slope < 0) {
      circleX = middleX - Math.abs(circleX - middleX);
      circleY = middleY - Math.abs(circleY - middleY);
    }
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = "green";
    ctx.moveTo(circleX, circleY);
    ctx.arc(circleX, circleY, circleRadius, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // return {x: circleX, y: circleY};
  };

function drawStatic() {
  // console.log("I'm drawStatic!;");
  let sineLength = parseInt(document.querySelector("canvas").getAttribute("width"));
  drawStrokeLine(0, 0, sineLength, "green");
  drawSine(0, sineLength, 50);
}

const circleSpeed = 150;  // px/s
const circleRadius = 20;
let sineLength = parseInt(document.querySelector("canvas").getAttribute("width"));
let trajectory = [...sineTrajectoryGen(0, sineLength, 50)];
let lastTrajIndex = 0;


function updateAnimation(timeStep) {
  ctx.save();
  ctx.clearRect(0, 0, sineLength, sineLength);
  ctx.translate(0, 250);
  drawStatic();

  let distanceToPass = timeStep * circleSpeed, distPassed = 0;
  // console.log(distanceToPass, sine);
  // let remainingTraj = trajectory.slice(lastTrajIndex, trajectory.length);
  for (let i=lastTrajIndex; i<trajectory.length; i++) {
    let coords = trajectory[i];
    let segment = distaneBetweenPoints(coords.x0, coords.y0, coords.x1, coords.y1);
    if (isNaN(segment)) {
      console.log("resulting line segment is NaN, convert to 0");
      segment = 0;
    }
    distPassed += segment;
    // console.log(`distance passed: ${distPassed}, distance yet to pass: ${distanceToPass - distPassed}`);
    if (distPassed >= distanceToPass) {
      drawCircleAdjacentToLine(ctx, coords.x0, coords.y0, coords.x1, coords.y1, circleRadius);
      break;
    }
    lastTrajIndex++;
  }
  if (lastTrajIndex + 1 >= trajectory.length) {
    console.log("Circle is out!");
    trajectory.reverse();
    lastTrajIndex = 0;
    // switch circle color

  }
  ctx.restore();
}


let lastTime = null;
function frame(time) {
  if (lastTime != null) {
    // console.log(Math.min(100, time - lastTime) / 1000);
    updateAnimation(Math.min(100, time - lastTime) / 1000);
  }
  lastTime = time;
  requestAnimationFrame(frame);
}

requestAnimationFrame(frame);

// function frame() {
//   updateAnimation(100 / 1000);
// };
//
// let interval = setInterval(frame, 100);


</script>
